import cProfile
import logging
import re
import sys
import time

import chainlit as cl
from lingua import LanguageDetector
from llama_index.core.callbacks import CallbackManager
from llama_index.core.chat_engine.types import BaseChatEngine

from callbacks import CustomLlamaIndexCallbackHandler
from citation import get_formatted_sources, get_source_graph, get_source_nodes
from lingua_iso_codes import IsoCode639_1
from pipelines import get_pipeline
from translation import BaseTranslator, detect_language, get_language_detector, get_translator, translate

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
logging.getLogger().addHandler(logging.StreamHandler(stream=sys.stdout))


@cl.on_chat_start
async def on_chat_start(accepted: bool = False):
    translator: BaseTranslator = get_translator()
    cl.user_session.set("translator", translator)
    initial_language_value = "Detect language"
    language_values = [initial_language_value] + [language.title() for language in translator.get_supported_languages(as_dict=True).keys()]
    await cl.ChatSettings(
        [
            cl.input_widget.Select(
                id="language",
                label="Language",
                values=language_values,
                initial_value=initial_language_value,
            )
        ]
    ).send()

    callback_manager = CallbackManager([CustomLlamaIndexCallbackHandler()])

    chat_engine_coroutine = cl.make_async(get_pipeline)(callback_manager=callback_manager)

    # display intro message and disclaimer
    descr = 'Hello! Welcome to Rare Disease Chatbot!'
    subhead = "I'm a chatbot designed to help you stay informed about the latest findings in rare diseases. I can access and understand research articles from PubMed, a large database of scientific publications.\n\nTo learn more, checkout the Readme page."
    disclaimer = 'Rare Disease Chatbot is an automated question answering tool, and is not intended to replace the advice of a qualified healthcare professional.\nContent generated by Rare Disease Chatbot is for informational purposes only, and is not advice for the treatment or diagnosis of any disease.'
    elements = [
        cl.Text(name=descr, content=subhead, display='inline'),
        cl.Text(name='Disclaimer', content=disclaimer, display='inline')
    ]
    await cl.Message(
        content = '',
        elements=elements,
    ).send()

    res = {}
    # continue prompting until user selects 'I understand'
    while not accepted:
        res = await cl.AskActionMessage(
            content='Do you understand the purpose and limitations of Rare Disease Chatbot?',
            actions = [
                cl.Action(name='I understand', value="continue", label='I Understand', description='Agree and continue'),
                cl.Action(name='Disagree', value="disagree", label='Disagree', description='Disagree to terms of service')
            ],
            timeout = 300  # five minutes
        ).send()

        accepted = res.get("value") == "continue"

        if not accepted:
            await cl.Message(
                content = "You must agree to the terms of service to continue."
            ).send()

    welcome = "Welcome! Ask me anything about rare diseases, and I'll do my best to find you the most relevant and up-to-date information."

    await cl.Message(content=welcome).send()
    chat_engine = await chat_engine_coroutine
    cl.user_session.set("chat_engine", chat_engine)

    iso_codes = [
        IsoCode639_1[code.upper()].value
        for code in translator.get_supported_languages(as_dict=True).values()
        if code.upper() in IsoCode639_1._member_names_
    ]
    detector = get_language_detector(*iso_codes)
    cl.user_session.set("detector", detector)


def chat(chat_engine: BaseChatEngine, content: str, profile: bool = False):
    if profile:
        pr = cProfile.Profile()
        pr.enable()
    response = chat_engine.chat(content)
    if profile:
        pr.disable()
        pr.dump_stats("profile.prof")
    return response


@cl.on_message
async def on_message(message: cl.Message):
    start = time.time()
    chat_engine: BaseChatEngine = cl.user_session.get("chat_engine")
    detector: LanguageDetector = cl.user_session.get("detector")
    translator: BaseTranslator = cl.user_session.get("translator")
    content = message.content

    language = cl.user_session.get("language")
    if not language or language == "auto":
        detection = await detect_language(detector, content)
        language = detection["language"]
    if language != "en" and language is not None:
        content = await translate(translator, content, source=language, target="en")

    response = await cl.make_async(chat)(chat_engine, content, profile=False)
    response_message = cl.Message(content="")

    content = response.response

    source_nodes = get_source_nodes(response, content)

    content = content.split("Sources:")[0].strip()
    content = re.sub(r"Source (\d+)", r"[\1]", content, flags=re.I)
    content = re.sub(r"\(\[", "[", content)
    content = re.sub(r"\]\)", "]", content)

    if language != "en" and language is not None:
        content = await translate(translator, content, source="en", target=language)

    if source_nodes:
        content += await get_formatted_sources(source_nodes)
        filename = get_source_graph(source_nodes)
        elements = [cl.Image(path=filename, display="inline", size="large")]
        response_message.elements = elements

    end = time.time()
    content += f"\n\n<small>{end - start:.2f} seconds</small>"
    response_message.content = content
    await response_message.send()


@cl.on_settings_update
def on_settings_update(settings: dict):
    language = settings["language"]
    translator: BaseTranslator = cl.user_session.get("translator")
    if language == "Detect language":
        language = "auto"
    else:
        language = translator.get_supported_languages(as_dict=True).get(language.lower())
    cl.user_session.set("language", language)
